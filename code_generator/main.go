package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"

	mysqlinfra "mercury_algo_backend/infra/mysql"

	"gorm.io/gorm"
)

const generatedFileSuffix = "_gen.go"

var fileTemplate = template.Must(template.New("model").Parse(`// Code generated by code_generator; DO NOT EDIT.

package {{.PackageName}}

{{- if .HasImports }}
import (
{{- range .Imports }}
    "{{.}}"
{{- end }}
)
{{- end }}

type {{.StructName}} struct {
{{- range .Fields }}
    {{.Name}} {{.Type}} ` + "`gorm:\"{{.GormTag}}\" json:\"{{.JSONTag}}\"`" + `{{if .Comment}} // {{.Comment}}{{end}}
{{- end }}
}

func ({{.StructName}}) TableName() string {
    return "{{.TableName}}"
}

type {{.StructName}}Repository struct {
    db *gorm.DB
}

func New{{.StructName}}Repository(db *gorm.DB) *{{.StructName}}Repository {
    return &{{.StructName}}Repository{db: db}
}

func (r *{{.StructName}}Repository) Create(ctx context.Context, entity *{{.StructName}}) error {
    return r.db.WithContext(ctx).Create(entity).Error
}

func (r *{{.StructName}}Repository) Save(ctx context.Context, entity *{{.StructName}}) error {
    return r.db.WithContext(ctx).Save(entity).Error
}

func (r *{{.StructName}}Repository) Delete(ctx context.Context, entity *{{.StructName}}) error {
    return r.db.WithContext(ctx).Delete(entity).Error
}
{{- if .HasPrimaryKey }}

func (r *{{.StructName}}Repository) Find(ctx context.Context, {{range $index, $pk := .PrimaryKeys}}{{if $index}}, {{end}}{{$pk.ParamName}} {{$pk.ParamType}}{{end}}) (*{{.StructName}}, error) {
    var entity {{.StructName}}
    query := r.db.WithContext(ctx)
{{- range .PrimaryKeys }}
    query = query.Where("{{.ColumnName}} = ?", {{.ParamName}})
{{- end }}
    if err := query.First(&entity).Error; err != nil {
        return nil, err
    }
    return &entity, nil
}
{{- end }}

func (r *{{.StructName}}Repository) List(ctx context.Context, limit int, offset int) ([]{{.StructName}}, error) {
    var entities []{{.StructName}}
    query := r.db.WithContext(ctx)
    if limit > 0 {
        query = query.Limit(limit)
    }
    if offset > 0 {
        query = query.Offset(offset)
    }
    if err := query.Find(&entities).Error; err != nil {
        return nil, err
    }
    return entities, nil
}
`))

func main() {
	cfg := loadConfig()
	if cfg.Database == "" {
		log.Fatal("a database name must be provided via --database or MYSQL_DATABASE")
	}

	db, err := mysqlinfra.Open(mysqlinfra.Config{
		Host:     cfg.Host,
		Port:     cfg.Port,
		Username: cfg.Username,
		Password: cfg.Password,
		Database: cfg.Database,
		Params:   cfg.Params,
	})
	if err != nil {
		log.Fatalf("failed to open database connection: %v", err)
	}

	sqlDB, err := db.DB()
	if err != nil {
		log.Fatalf("failed to acquire sql DB: %v", err)
	}
	defer sqlDB.Close()

	if err := os.MkdirAll(cfg.OutputDir, 0o755); err != nil {
		log.Fatalf("failed to ensure output directory: %v", err)
	}

	if !cfg.SkipClean {
		if err := cleanupGeneratedFiles(cfg.OutputDir); err != nil {
			log.Fatalf("failed to clean previously generated files: %v", err)
		}
	}

	tables, err := loadTables(db, cfg.Database)
	if err != nil {
		log.Fatalf("failed to load table metadata: %v", err)
	}

	if len(tables) == 0 {
		log.Printf("no tables found in schema %q", cfg.Database)
		return
	}

	for _, tableName := range tables {
		columns, err := loadColumns(db, cfg.Database, tableName)
		if err != nil {
			log.Fatalf("failed to describe table %s: %v", tableName, err)
		}

		if len(columns) == 0 {
			log.Printf("table %s has no columns, skipping", tableName)
			continue
		}

		data := buildTemplateData(cfg.PackageName, tableName, columns)
		if err := writeTableFile(cfg.OutputDir, tableName, data); err != nil {
			log.Fatalf("failed to write file for table %s: %v", tableName, err)
		}
		log.Printf("generated %s", tableName)
	}
}

type generatorConfig struct {
	Host        string
	Port        string
	Username    string
	Password    string
	Database    string
	Params      string
	OutputDir   string
	PackageName string
	SkipClean   bool
}

func loadConfig() generatorConfig {
	defaultOutput := filepath.Join("infra", "mysql")

	host := flag.String("host", getenv("MYSQL_HOST", "127.0.0.1"), "MySQL host")
	port := flag.String("port", getenv("MYSQL_PORT", "3306"), "MySQL port")
	username := flag.String("user", getenv("MYSQL_USER", "root"), "MySQL user")
	password := flag.String("password", os.Getenv("MYSQL_PASSWORD"), "MySQL password")
	database := flag.String("database", os.Getenv("MYSQL_DATABASE"), "MySQL database name")
	params := flag.String("params", getenv("MYSQL_PARAMS", "parseTime=true&loc=Local&charset=utf8mb4"), "additional DSN parameters")
	output := flag.String("out", getenv("GEN_OUTPUT", defaultOutput), "directory for generated files")
	pkg := flag.String("package", getenv("GEN_PACKAGE", "mysql"), "package name for generated code")
	skipClean := flag.Bool("skip-clean", false, "skip removing previous generated files")

	flag.Parse()

	return generatorConfig{
		Host:        *host,
		Port:        *port,
		Username:    *username,
		Password:    *password,
		Database:    *database,
		Params:      *params,
		OutputDir:   *output,
		PackageName: *pkg,
		SkipClean:   *skipClean,
	}
}

func getenv(key, fallback string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return fallback
}

func cleanupGeneratedFiles(dir string) error {
	entries, err := os.ReadDir(dir)
	if err != nil {
		if errors.Is(err, fs.ErrNotExist) {
			return os.MkdirAll(dir, 0o755)
		}
		return err
	}

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		if strings.HasSuffix(entry.Name(), generatedFileSuffix) {
			if err := os.Remove(filepath.Join(dir, entry.Name())); err != nil {
				return err
			}
		}
	}

	return nil
}

func loadTables(db *gorm.DB, schema string) ([]string, error) {
	type tableRow struct {
		TableName string `gorm:"column:TABLE_NAME"`
	}

	var tables []tableRow
	query := "SELECT TABLE_NAME FROM information_schema.tables WHERE table_schema = ? AND table_type = 'BASE TABLE' ORDER BY TABLE_NAME"
	if err := db.Raw(query, schema).Scan(&tables).Error; err != nil {
		return nil, err
	}

	result := make([]string, 0, len(tables))
	for _, table := range tables {
		result = append(result, table.TableName)
	}
	return result, nil
}

func loadColumns(db *gorm.DB, schema, table string) ([]columnInfo, error) {
	type columnRow struct {
		ColumnName string  `gorm:"column:COLUMN_NAME"`
		ColumnType string  `gorm:"column:COLUMN_TYPE"`
		DataType   string  `gorm:"column:DATA_TYPE"`
		IsNullable string  `gorm:"column:IS_NULLABLE"`
		ColumnKey  string  `gorm:"column:COLUMN_KEY"`
		Extra      string  `gorm:"column:EXTRA"`
		Comment    *string `gorm:"column:COLUMN_COMMENT"`
	}

	var columns []columnRow
	query := `SELECT COLUMN_NAME, COLUMN_TYPE, DATA_TYPE, IS_NULLABLE, COLUMN_KEY, EXTRA, COLUMN_COMMENT
FROM information_schema.columns
WHERE table_schema = ? AND table_name = ?
ORDER BY ORDINAL_POSITION`
	if err := db.Raw(query, schema, table).Scan(&columns).Error; err != nil {
		return nil, err
	}

	result := make([]columnInfo, 0, len(columns))
	for _, c := range columns {
		info := columnInfo{
			Name:       c.ColumnName,
			ColumnType: c.ColumnType,
			DataType:   c.DataType,
			Nullable:   strings.EqualFold(c.IsNullable, "YES"),
			PrimaryKey: strings.EqualFold(c.ColumnKey, "PRI"),
			AutoInc:    strings.Contains(strings.ToLower(c.Extra), "auto_increment"),
		}
		if c.Comment != nil {
			info.Comment = strings.TrimSpace(*c.Comment)
		}
		result = append(result, info)
	}

	return result, nil
}

type columnInfo struct {
	Name       string
	ColumnType string
	DataType   string
	Nullable   bool
	PrimaryKey bool
	AutoInc    bool
	Comment    string
}

type field struct {
	Name           string
	Type           string
	NonPointerType string
	ColumnName     string
	JSONTag        string
	GormTag        string
	Comment        string
}

type primaryKey struct {
	ColumnName string
	ParamName  string
	ParamType  string
}

type templateData struct {
	PackageName   string
	StructName    string
	TableName     string
	Fields        []field
	Imports       []string
	HasImports    bool
	HasPrimaryKey bool
	PrimaryKeys   []primaryKey
}

func buildTemplateData(pkgName, tableName string, columns []columnInfo) templateData {
	structName := toCamelCase(tableName)
	if structName == "" {
		structName = "Model"
	}

	fields := make([]field, 0, len(columns))
	primaryKeys := make([]primaryKey, 0)
	usesTime := false

	for _, column := range columns {
		goType, timeRequired := mapColumnType(column)
		if timeRequired {
			usesTime = true
		}

		fieldName := sanitizeIdentifier(toCamelCase(column.Name))
		nonPointerType := strings.TrimPrefix(goType, "*")

		gormTag := buildGormTag(column)
		jsonTag := column.Name

		fields = append(fields, field{
			Name:           fieldName,
			Type:           goType,
			NonPointerType: nonPointerType,
			ColumnName:     column.Name,
			JSONTag:        jsonTag,
			GormTag:        gormTag,
			Comment:        column.Comment,
		})

		if column.PrimaryKey {
			primaryKeys = append(primaryKeys, primaryKey{
				ColumnName: column.Name,
				ParamName:  toLowerCamel(fieldName),
				ParamType:  nonPointerType,
			})
		}
	}

	imports := []string{"context", "gorm.io/gorm"}
	if usesTime {
		imports = append(imports, "time")
	}

	sort.Strings(imports)

	return templateData{
		PackageName:   pkgName,
		StructName:    structName,
		TableName:     tableName,
		Fields:        fields,
		Imports:       imports,
		HasImports:    len(imports) > 0,
		HasPrimaryKey: len(primaryKeys) > 0,
		PrimaryKeys:   primaryKeys,
	}
}

func mapColumnType(column columnInfo) (string, bool) {
	typeName := strings.ToLower(column.DataType)
	columnType := strings.ToLower(column.ColumnType)
	unsigned := strings.Contains(columnType, "unsigned")

	timeRequired := false
	var goType string

	switch typeName {
	case "tinyint":
		if strings.HasPrefix(columnType, "tinyint(1)") {
			goType = "bool"
		} else if unsigned {
			goType = "uint8"
		} else {
			goType = "int8"
		}
	case "smallint":
		if unsigned {
			goType = "uint16"
		} else {
			goType = "int16"
		}
	case "mediumint", "int", "integer":
		if unsigned {
			goType = "uint"
		} else {
			goType = "int"
		}
	case "bigint":
		if unsigned {
			goType = "uint64"
		} else {
			goType = "int64"
		}
	case "float", "double", "decimal", "numeric":
		goType = "float64"
	case "bit":
		if strings.HasPrefix(columnType, "bit(1)") {
			goType = "bool"
		} else {
			goType = "[]byte"
		}
	case "boolean", "bool":
		goType = "bool"
	case "char", "varchar", "text", "tinytext", "mediumtext", "longtext", "enum", "set":
		goType = "string"
	case "json":
		goType = "[]byte"
	case "binary", "varbinary", "blob", "tinyblob", "mediumblob", "longblob":
		goType = "[]byte"
	case "date", "datetime", "timestamp", "time":
		goType = "time.Time"
		timeRequired = true
	case "year":
		goType = "int"
	default:
		goType = "string"
	}

	if column.Nullable && goType != "[]byte" {
		if goType == "time.Time" {
			goType = "*time.Time"
		} else if !strings.HasPrefix(goType, "*") {
			goType = "*" + goType
		}
	}

	return goType, timeRequired
}

func buildGormTag(column columnInfo) string {
	tags := []string{"column:" + column.Name}
	if column.PrimaryKey {
		tags = append(tags, "primaryKey")
	}
	if column.AutoInc {
		tags = append(tags, "autoIncrement")
	}
	return strings.Join(tags, ";")
}

func writeTableFile(outputDir, tableName string, data templateData) error {
	filename := sanitizeFileName(tableName) + generatedFileSuffix
	path := filepath.Join(outputDir, filename)

	var buf bytes.Buffer
	if err := fileTemplate.Execute(&buf, data); err != nil {
		return err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("formatting generated code: %w", err)
	}

	return os.WriteFile(path, formatted, 0o644)
}

func sanitizeFileName(name string) string {
	name = strings.TrimSpace(name)
	if name == "" {
		return "table"
	}

	var builder strings.Builder
	builder.Grow(len(name))
	underscore := false
	for _, r := range name {
		switch {
		case unicode.IsLetter(r) || unicode.IsDigit(r):
			builder.WriteRune(unicode.ToLower(r))
			underscore = false
		default:
			if !underscore {
				builder.WriteRune('_')
				underscore = true
			}
		}
	}

	result := strings.Trim(builder.String(), "_")
	if result == "" {
		return "table"
	}
	return result
}

func toCamelCase(input string) string {
	if input == "" {
		return ""
	}

	var result strings.Builder
	uplow := true
	for _, r := range input {
		if r == '_' || r == '-' || r == ' ' {
			uplow = true
			continue
		}
		if uplow {
			result.WriteRune(unicode.ToUpper(r))
			uplow = false
		} else {
			result.WriteRune(unicode.ToLower(r))
		}
	}

	return result.String()
}

func toLowerCamel(input string) string {
	if input == "" {
		return input
	}
	r, size := utf8.DecodeRuneInString(input)
	if r == utf8.RuneError && size == 0 {
		return input
	}
	return strings.ToLower(string(r)) + input[size:]
}

var reservedIdentifiers = map[string]struct{}{
	"break":       {},
	"default":     {},
	"func":        {},
	"interface":   {},
	"select":      {},
	"case":        {},
	"defer":       {},
	"go":          {},
	"map":         {},
	"struct":      {},
	"chan":        {},
	"else":        {},
	"goto":        {},
	"package":     {},
	"switch":      {},
	"const":       {},
	"fallthrough": {},
	"if":          {},
	"range":       {},
	"type":        {},
	"continue":    {},
	"for":         {},
	"import":      {},
	"return":      {},
	"var":         {},
}

func sanitizeIdentifier(name string) string {
	if name == "" {
		return "Field"
	}

	if _, exists := reservedIdentifiers[strings.ToLower(name)]; exists {
		name = name + "Value"
	}

	r, _ := utf8.DecodeRuneInString(name)
	if unicode.IsDigit(r) {
		name = "Field" + name
	}

	return name
}
